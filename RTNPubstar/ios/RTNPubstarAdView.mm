// RTNPubstarAdView.mm
#import "RTNPubstarAdView.h"

#import <react/renderer/components/RTNPubstarSpec/ComponentDescriptors.h>
#import <react/renderer/components/RTNPubstarSpec/EventEmitters.h>
#import <react/renderer/components/RTNPubstarSpec/Props.h>
#import <react/renderer/components/RTNPubstarSpec/RCTComponentViewHelpers.h>


#import "rtn_pubstar-Swift.h"

// Here you might need to import missing headers to satisfy Swift header file compilation
//#import <WatchConnectivity/WatchConnectivity.h>
//#import <ExpoModulesCore-Swift.h>

// This is autogenerated Swift header file - more info here: https://developer.apple.com/documentation/swift/importing-swift-into-objective-c
// #import "YourApp-Swift.h"

using namespace facebook::react;

@interface RTNPubstarAdView () <RCTPubstarAdViewViewProtocol>
@end

@implementation RTNPubstarAdView {
    UIView *_view;
    PubstarImpl *moduleImpl;
    NSString *adId;
    NSString *size;
    NSString *type;
}

- (instancetype)init
{
    self = [super init];
    if (self) {
        NSLog(@"---init: %@", [self description]);
        moduleImpl = [PubstarImpl new];
    }
    return self;
}

- (instancetype)initWithFrame:(CGRect)frame
{
    NSLog(@"---initWithFrame");
    if (self = [super initWithFrame:frame]) {
        static const auto defaultProps = std::make_shared<const PubstarAdViewProps>();
        _props = defaultProps;
      
        _view = [[UIView alloc] init];
        _view.backgroundColor = [UIColor blackColor];

        [self addSubview:_view];
  }

  return self;
}

- (void)dealloc {
    
}

+ (void)load
{
    [super load];
    NSLog(@"---load");
}

//  You can listen to this lifecycle event to pause / resume operations as Fabric components are kept in memory to be reused later
-(void)didMoveToSuperview {
    NSLog(@"---didMoveToSuperview");
    if (self.superview != nil) {
        // Manually triggering events that child third-party views/controllers listen to resume operations
        
        if ([type  isEqual: @"banner"]) {
            [moduleImpl loadAndShowBannerAdWithAdId:adId view: _view size: size onLoaderError:^(NSInteger errorCode) {
                    NSDictionary *error =
                        @{@"name" : @"LOADED_ERROR",
                          @"code" : @(errorCode)};

                    NSLog(@"---onLoaderError");
            } onLoaded:^{
                NSLog(@"---onLoaded");
            } onHide:^{
                NSLog(@"---onHide");
            } onShowed:^{
                NSLog(@"---onShowed");
            } onShowedError:^(NSInteger errorCode) {
                NSDictionary *error =
                    @{@"name" : @"LOADED_ERROR",
                      @"code" : @(errorCode)};

                NSLog(@"---onShowedError");
            }];
            return;
        }
        
        if ([type  isEqual: @"native"]) {
            NSLog(@"---loadAndShowNativeAdWithAdId - size: %@ - adId: %@", size, adId);
            [moduleImpl loadAndShowNativeAdWithAdId:adId view: _view size: size onLoaderError:^(NSInteger errorCode) {
                    NSDictionary *error =
                        @{@"name" : @"LOADED_ERROR",
                          @"code" : @(errorCode)};

                    NSLog(@"---onLoaderError");
            } onLoaded:^{
                NSLog(@"---onLoaded");
            } onHide:^{
                NSLog(@"---onHide");
            } onShowed:^{
                NSLog(@"---onShowed");
            } onShowedError:^(NSInteger errorCode) {
                NSDictionary *error =
                    @{@"name" : @"LOADED_ERROR",
                      @"code" : @(errorCode)};

                NSLog(@"---onShowedError");
            }];
            return;
        }
        
    }
}

// Seems good practice to notify child views about changes in bounds
-(void)layoutSubviews
{
    [super layoutSubviews];
    NSLog(@"---self.bounds.size.width: %f", self.bounds.size.width);
    NSLog(@"---self.bounds.size.height: %f", self.bounds.size.height);
    _view.frame = self.bounds;
}

// Updating the child view props
- (void)updateProps:(Props::Shared const &)props oldProps:(Props::Shared const &)oldProps
{
NSLog(@"---updateProps");
    const auto &oldViewProps = *std::static_pointer_cast<PubstarAdViewProps const>(_props);
    const auto &newViewProps = *std::static_pointer_cast<PubstarAdViewProps const>(props);

    if (oldViewProps.size != newViewProps.size) {
      size = [[NSString alloc] initWithCString:newViewProps.size.c_str() encoding:NSASCIIStringEncoding];
    }
    
    if (oldViewProps.adId != newViewProps.adId) {
        adId = [[NSString alloc] initWithCString:newViewProps.adId.c_str() encoding:NSASCIIStringEncoding];
    }
    
    if (oldViewProps.type != newViewProps.type) {
        type = [[NSString alloc] initWithCString:newViewProps.type.c_str() encoding:NSASCIIStringEncoding];
    }
    

  [super updateProps:props oldProps:oldProps];
}
//
//// Emitting event back to JS. This method is called from Swift view
//- (void)onPhotoEvent:(NSDictionary<NSString *, NSString *> *)imageData {
//    if (_eventEmitter) {
//        CameraNativeComponentEventEmitter::OnPhoto eventStruct;
//
//        // Stringify is done as currently the RN codegen does not support numbers in TypeScript
//        eventStruct.uri = [imageData[@"uri"] UTF8String];
//        eventStruct.croppedImageUri = [imageData[@"croppedImageUri"] UTF8String];
//        eventStruct.processedImageUri = [imageData[@"processedImageUri"] UTF8String];
//
//        self.eventEmitter.onPhoto(eventStruct);
//    }
//}

// Event emitter convenience method
//- (const CameraNativeComponentEventEmitter &)eventEmitter
//{
//  return static_cast<const CameraNativeComponentEventEmitter &>(*_eventEmitter);
//}

+ (ComponentDescriptorProvider)componentDescriptorProvider
{
  return concreteComponentDescriptorProvider<PubstarAdViewComponentDescriptor>();
}

@end
